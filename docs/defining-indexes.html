<!DOCTYPE html>
<html>
<head>
    <title>Caltech Library's Digital Library Development Sandbox</title>
    <link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="/css/site.css">
</head>
<body>
<header>
<a href="http://library.caltech.edu"><img src="/assets/liblogo.gif" alt="Caltech Library logo"></a>
</header>
<nav>
<ul>
<li><a href="/">Home</a></li>
<li><a href="../">README</a></li>
<li><a href="../license.html">LICENSE</a></li>
<li><a href="../install.html">INSTALL</a></li>
<li><a href="./">Documentation</a></li>
<li><a href="../how-to/">How To</a></li>
<li><a href="https://github.com/caltechlibrary/dataset">Github</a></li>
</ul>

</nav>

<section>
<h1>Defining Indexes</h1>

<p><em>dsindexer</em> builds an index from an index definition file. The definition file is a JSON document.</p>

<h2>A minimal index definition</h2>

<p><em>dsindexer</em> works from a index definition expressed as a JSON document. The most important of the definition is to map
a indexed field name to a path in the JSON document being index. This is done with dotpath notation as the value associated
with a field name in the index.</p>

<p>If your JSON document looks like</p>

<pre><code class="language-json">    {
        &quot;last_name&quot;: &quot;Smiley&quot;,
        &quot;first_name&quot;: &quot;George&quot;,
        &quot;bio&quot;: {
            &quot;date_of_birth&quot;: &quot;1906-09-21&quot;,
            &quot;birth_place&quot;: {
                &quot;name&quot;: &quot;UK, England, Salisbury&quot;,
                &quot;geo_coord&quot;:&quot;51.0797058,-1.8434485&quot;
            }
        },
        &quot;email&quot;:&quot;smiley.george@emeritus.circus.example.net&quot;
    }
</code></pre>

<p>You could create an index of last name and date of birth with the following definition</p>

<pre><code class="language-json">    {
        &quot;last_name&quot;: {
            &quot;object_path&quot;: &quot;.last_name&quot;
        },
        &quot;dob&quot;: {
            &quot;object_path&quot;: &quot;.bio.date_of_birth&quot;
        }
    }
</code></pre>

<p>The dotpath notation lets you reach into a nested JSON property and bring it out into a field that will
be indexed.</p>

<h2>Working with field mappings</h2>

<p>In our example of above we have three types of data in our JSON document.  The name properties are
strings. The date of birth property is a date in YYYY-MM-DD format and finally we have an email
address. In our initial index definition we treat all these values as strings.  This is fine for
the names and email address but if we want to work with date ranges then the date of birth should
be handled differently. It should be handled as a date.</p>

<p>Here&rsquo;s a revised definition</p>

<pre><code class="language-json">    {
        &quot;last_name&quot;: {
            &quot;object_path&quot;: &quot;.last_name&quot;
        },
        &quot;dob&quot;: {
            &quot;object_path&quot;: &quot;.bio.date_of_birth&quot;,
            &quot;field_mapping&quot;: &quot;datetime&quot;
        }
    }
</code></pre>

<p><em>dsindexer</em> supports four types of field mappings</p>

<ul>
<li>text - this is the default and is what you would use for titles</li>
<li>numeric - use this for indexing numeric values</li>
<li>datetime - use this for indexing dates and time values</li>
<li>boolean - use this for indexing true/value values</li>
<li>geopoint - use this for indexing Geo Point data</li>
</ul>

<p>If we want to expand our definition to include the location of Smiley&rsquo;s birth we add the geocordinates too.</p>

<pre><code class="language-json">    {
        &quot;last_name&quot;: {
            &quot;object_path&quot;: &quot;.last_name&quot;
        },
        &quot;dob&quot;: {
            &quot;object_path&quot;: &quot;.bio.date_of_birth&quot;,
            &quot;field_mapping&quot;: &quot;datetime&quot;
        },
        &quot;origin&quot;: {
            &quot;object_path&quot;: &quot;.bio.birth_place.geo_coord&quot;,
            &quot;field_mapping&quot;: &quot;geopoint&quot;
        }
    }
</code></pre>

<h2>Working with analyzers</h2>

<p>In addition to setting the controlling how the values are mapped into the index you can control the analysis
that are applied when building your index (see <a href="http://www.blevesearch.com/docs/Analyzers/">http://www.blevesearch.com/docs/Analyzers/</a> for details).
Analyzers include applying language rules for understanding the text analyzed. This includes handling things
like stop word removal, language settings.</p>

<p><em>dsindexer</em> support the following types of analyzers</p>

<ul>
<li>keyword - performs zero analysis, use this if you want to treat the value as is</li>
<li>simple - performs minimal analysis, tokenizes using Unicode and lowercases the value</li>
<li>standard - is like simple but adds English stop word removal</li>
<li>detectlang - tries to determine the language then applies that languages analyzer applying its rules (e.g. if
the language detected was German then German stop words, analysis would be performed)</li>
<li>lang - will look use a language specific analyzer (relying on the lang property for language name, e.g. en, es, de, cjk)</li>
</ul>

<p>Language analyzers current supported (as of 2017-05-09) by are - Danish (da), Dutch (nl), English (en), Finnish (fi),
French (fr), German (de), Hungarian (hu), Italian (it), Norwegian (no), Persian (fa), Portuguese (pt), Romanian (ro),
Russian (ru), Sorani (ckb), Spanish (es), Swedish (sv), Thai (th), Turkish (tr).</p>

<p>Let&rsquo;s consider a JSON document that has a title and abstract field.</p>

<pre><code class="language-json">    {
        &quot;title&quot;: &quot;Some title here&quot;,
        &quot;abstract&quot;: &quot;blah, blah, blah, hurmph, bip&quot;
    }
</code></pre>

<p>We could index these with a definition like if we wanted to use the &ldquo;detectlang&rdquo; analyzer.</p>

<pre><code class="language-json">    {
        &quot;title&quot;: {
            &quot;object_path&quot;: &quot;.title&quot;,
            &quot;field_mapping&quot;: &quot;text&quot;,
            &quot;analyzers&quot;: &quot;detectlang&quot;
        },
        &quot;abstract&quot;: {
            &quot;object_path&quot;: &quot;.abstract&quot;,
            &quot;field_mapping&quot;: &quot;text&quot;,
            &quot;analyzers&quot;: &quot;detectlang&quot;
        }
    }
</code></pre>

<p>If knew our documents were always in Danish we could try something like this definition&ndash;</p>

<pre><code class="language-json">    {
        &quot;title&quot;: {
            &quot;object_path&quot;: &quot;.title&quot;,
            &quot;field_mapping&quot;: &quot;text&quot;,
            &quot;analyzers&quot;: &quot;lang&quot;,
            &quot;lang&quot;: &quot;da&quot;
        },
        &quot;abstract&quot;: {
            &quot;object_path&quot;: &quot;.abstract&quot;,
            &quot;field_mapping&quot;: &quot;text&quot;,
            &quot;analyzers&quot;: &quot;lang&quot;,
            &quot;lang&quot;: &quot;da&quot;
        }
    }
</code></pre>

<p>Note you can use different analyzers on different fields.</p>

<h2>Additoinal configuration</h2>

<p>This additional configuration is useful for managing the size your of your index(es) on disc as
well as impact the ammount of time it takes to index your data.</p>

<h3>Storing the field values in the index</h3>

<p>As we define the numbers of fields in our index the size the index will also grow.  If you don&rsquo;t need to
see the field in the results you can choose not to store it in the index.  This is done with the &ldquo;store&rdquo;
attribute in the field&rsquo;s definition. The value can be true/false.</p>

<h2>Include Term Vectors</h2>

<p>You can choose to include term vectors in your index. This is set by the field property called &ldquo;include_term_vectors&rdquo;
and like &ldquo;store&rdquo; it can be either true/false.</p>

<h2>Include In all</h2>

<p>&ldquo;include_in_all&rdquo;, not clear on what this does but it&rsquo;s configurable so <em>dsindexer</em> supports it.</p>

<h2>Date Format</h2>

<p>The &ldquo;date_format&rdquo; string is used to indentify how to parse the date. The formatting pattern is based on Go&rsquo;s time.Parse()
module. You can read more about that here at <a href="https://golang.org/pkg/time/#pkg-constants">https://golang.org/pkg/time/#pkg-constants</a>. If you&rsquo;re using the &ldquo;datetime&rdquo;
field mapping for a field you should probably set the &ldquo;date_format&rdquo; too since dates can be written so many ways.</p>

</section>

<footer>
<span><h1><A href="http://caltech.edu">Caltech</a></h1></span>
<span>&copy; 2017 <a href="https://www.library.caltech.edu/copyright">Caltech library</a></span>
<address>1200 E California Blvd, Mail Code 1-32, Pasadena, CA 91125-3200</address> 
<span>Phone: <a href="tel:+1-626-395-3405">(626)395-3405</a></span>
<span><a href="mailto:library@caltech.edu">Email Us</a></span>
<a class="cl-hide" href="sitemap.xml">Site Map</a>
</footer>
</body>
</html>
